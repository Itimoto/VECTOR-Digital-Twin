%% DoA via MUSIC + Positioning
% No Noise, No Multipathing
% Trying to determine DoA via MUSIC

% NOTE! This is very volatile, and I've done a big no-no, which is 
%  making hotfixes to write a report in time. When fixing this later
%  UPDATE THE GRAPHS TO REFLECT THAT MOST OF THEM (NOT THE MUSIC ALG)
%  ONLY CONSIDER THE FIRST SNAPSHOT AND DO NOT CORRELATE OVER TIME!

% Generates two CSI plots. The left one is generated by the NDP from the
% Ranging Process. The right one is generated by the Channel Impulse Response
% Note the behavior for the NDP-generated CSI with a LOS-based channel (pm.MaxNumReflections = 0) --
%   compared to the CIR-generated CSI, there is a phase gradient present.

%% MIMO-OFDM Raytracing Comm + 802.11az Super-Resolution Time of Arrival Estimator
% Combination of MIMO-OFDM example: https://www.mathworks.com/help/comm/ug/indoor-mimo-ofdm-communication-link-using-ray-tracing.html
% and 802.11az Positioning example: https://www.mathworks.com/help/wlan/ug/802-11az-indoor-positioning-using-super-resolution-time-of-arrival-estimation.html

%%%%%%%% VARIABLES OF INTEREST %%%%%%%%%%%%%
% numSTAant = # of Transmit Antennas on User Terminal
% numAPant = # of Receive Antennas on Base Station
% R_a = Linear Distance from TX to RX
% beta_a = Angular Position of RX relative to TX (angle off array parallel)
% tx.AntennaPosition = TX antenna position
% rx.AntennaPosition = RX antenna position
% pm.MaxNumReflections = Max Number of simulated reflections in Ray Tracing Simulation
% EbNo = approximate EbNo for system. To remove noise, set EbNo = inf
% bw = Channel Bandwidth, according to specification
% numSnapshots = number of CSI snapshots. Useful for temporal correlation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

clear all;
%close all;
%clc;

%% 3D Outdoor Scenario
c = physconst('lightspeed');
fc = 2.437e9; % Carrier frequency
lambda = c/fc;
spacing = (3.5e-2)/lambda; % 3/4 Lambda Spacing

numSTAant = 2;  % # of Transmit Antennas (on User Terminal)
numAPant = 4;   % # of Receive Antennas (on Base Station)
txArray = arrayConfig("Size",[1 numSTAant],"ElementSpacing",spacing*lambda);
rxArray = arrayConfig("Size",[1 numAPant],"ElementSpacing",spacing*lambda);

R_a = 1.25; % Linear Distance between TX and RX
beta_a = 110+0; % Direction of TX, with respect to RX (in degrees)
            % 0 degrees is parallel to the array, on the right-hand side
            %   relative to the X-Z plane visualized by `helperViewArray`
            % 10 degrees moves clockwise about the Z axis 

helper.helperViewArray(rxArray); % For RX URA APA

% Specify a transmitter site close to the upper corner of the room, which
% can be a WiFi accesss point
tx = txsite("cartesian", ...
    "Antenna",txArray, ...
    'TransmitterFrequency',fc);

rx = rxsite("cartesian", ...
    "Antenna",rxArray, ...
    "AntennaAngle",[0; 0]); % Rotate RX array by the angle we're trying to simulate

tx.AntennaPosition = [R_a*cos(deg2rad(beta_a - 90)); R_a*sin(deg2rad(beta_a - 90)); 0.2];% Place TX Antenna some distance away
rx.AntennaPosition = [0; 0; 0.3]; % Place RX Antenna at the origin  

% Use the siteviewer function with the map file specified to view the scene
% in 3D. Use show function to visualize the transmitters and receivers
%siteviewer("Terrain", 'none', "Hidden",true); % To have 'nothing' / empty space
siteviewer("SceneModel","conferenceroom.stl"); % Uncomment to simulate multipath
show(tx,"ShowAntennaHeight",false)
show(rx,"ShowAntennaHeight",false)
pattern(rx, fc); % For a ULA, the array is facing the direction of the main lobe, flaring out at the sides

%% Ray Tracing Model
% Perform raytracing analysis between the transmitter and receiver sites
% and return the comm.Ray objects, using the Shooting and Bouncing rays
% (SBR) method. Specify the surface material of the scene as wood and
% search for rays with up to 2 reflections. SBR method supports up to 10
% orders of reflections
pm = propagationModel("raytracing", ...
    "CoordinateSystem","cartesian", ...
    "Method","sbr", ...
    "AngularSeparation","low", ...
    "SurfaceMaterial","plasterboard");
pm.MaxNumReflections = 10; % If 0: No reflections, LOS only

rays = raytrace(tx,rx,pm);

% Extract computed rays from the cell array return
rays = rays{1,1};
% Examine the ray tracing results by looking at the number of reflections:
[rays.NumInteractions]
% ...propagation distance...
[rays.PropagationDistance]
% ...and path loss value of each ray
[rays.PathLoss]
% Use the plot function to plot the rays in the 3D scene in Siteviewer,
% with each ray colored based on path loss value
plot(rays,"Colormap",jet,"ColorLimits",[50, 95]);

%% Deterministic Channel Model from Ray Tracing
% Create a deterministic multipath channel model using the above ray
% tracing results. Specify the instananeous velocity of the receiver to
% reflect typical low mobility of a device in the indoor environment
rtChan = comm.RayTracingChannel(rays,tx,rx);
rtChan.SampleRate = 300e6;
rtChan.ReceiverVirtualVelocity = [0.1;0.1;0];

% Assign Eb/No value and derive SNR value from it for AWGN
bitsPerCarrier = 6; % Suppose we're using 64-QAM, which exists for 802.11ac & az
codeRate = 2/3;     % worst case 1/2, best case 5/6
EbNo = 12; % In dB
SNR = convertSNR(EbNo,"ebno", ...
  "BitsPerSymbol",bitsPerCarrier, ... % worst case 1, best case 10
  "CodingRate",codeRate);             % worst case 1/2, best case 5/6  
SNRLin = 10^(SNR/10);      % Linear

%% 802.11az Waveform Configuration
bw = 20;
chanBW = "CBW"+num2str(bw); % 20MHz Channel
numSTS = min([numSTAant numAPant]);%numSTAant * numAPant; % # of Space-Time Streams
numLTFRepetitions = 8;  % # of HE-LTF repetitions

% Configure the HE ranging NDP parameters of the STA (User Terminal)
cfgSTABase = ranging.heRangingConfig;
cfgSTABase.ChannelBandwidth = chanBW;
cfgSTABase.NumTransmitAntennas = numSTAant;
cfgSTABase.SecureHELTF = true;
cfgSTABase.User{1}.NumSpaceTimeStreams = numSTS;
cfgSTABase.User{1}.NumHELTFRepetition = numLTFRepetitions;
cfgSTABase.GuardInterval = 1.6;

% Configure HE ranging NDP parameters of the AP (Base Station)
cfgAPBase = ranging.heRangingConfig;
cfgAPBase.ChannelBandwidth = chanBW;
cfgAPBase.NumTransmitAntennas = min([numSTAant numAPant]);
cfgAPBase.SecureHELTF = true;
cfgAPBase.User{1}.NumSpaceTimeStreams = numSTS;
cfgAPBase.User{1}.NumHELTFRepetition = numLTFRepetitions;
cfgAPBase.GuardInterval = 1.6;

ofdmInfo = wlanHEOFDMInfo('HE-LTF',chanBW,cfgSTABase.GuardInterval);
sampleRate = wlanSampleRate(chanBW);

% Miscellaneous channel config variables
chBaseInfo = info(rtChan);
chDelay = chBaseInfo.ChannelFilterDelay;
numPaths = size(rays, 2); % Number of paths simulated

%% Ranging Measurement
delayULDL = 16e-6; % Time Delay between UL NDP ToA and DL NDP ToD, in seconds

% Use a separate channel and waveform config object for each (potential)
% parfor stream, which would start here. -- Iterates over the SNR values
chan = rtChan; % Set it to the Raytracing Channel we generated earlier
cfgAP = cfgAPBase;
cfgSTA = cfgSTABase;

% Initialize ranging error and total failed packet count variables
rangingError = 0;
failedPackets = 0;

% Set random substream index per (potential) iteration to ensure each
% iteration uses a repeatable set of random numbers
stream = RandStream('combRecursive','Seed',654321);
stream.Substream = 1; % Would be equal to index in parfor loop
RandStream.setGlobalStream(stream);

% Define SNR per active subcarrier to account for noise energy in nulls
snrVal = SNR - 10*log10(ofdmInfo.FFTLength/ofdmInfo.NumTones);

% 802.11az Pos Example starts Monte Carlo here
% Range-based delay
delay = distance(tx, rx)/c; % Divide out the speed of light
sampleDelay = delay*sampleRate;

% Loop over different APs starts here
linkType = ["Uplink","Downlink"];
% ToD of UL NDP (t1)
todUL = randsrc(1,1,0:1e-9:1e-6);
% Loop for both UL and DL transmission
numLinks = numel(linkType);
txTime = zeros(1,numLinks);

numSnapshots = 200; % Number of Snapshots for which we will generate CSI
% Carry-overs will consider only the first. MUSIC & other estimators will
% use the following CSI matrix:
Hest_Multi = zeros(numSTAant, numAPant, ofdmInfo.NumTones, numSnapshots); % [AT AR S K]

for k = 1:numSnapshots
    for l = 1:numLinks
        if linkType(l) == "Uplink" % STA to AP
            cfgSTA.UplinkIndication = 1; % For UL
            % Generate a random secure HE-LTF sequence for the exchange
            cfgSTA.User{1}.SecureHELTFSequence = dec2hex(randsrc(1,10,(0:15)))';
            cfg = cfgSTA;
        else                        % AP to STA
            % Generate a random secure HE-LTF sequence for the exchange
            cfgAP.User{1}.SecureHELTFSequence = dec2hex(randsrc(1,10,(0:15)))';
            cfg = cfgAP;    % For DL
        end
    
        % Set different channel for UL and DL, assuming that the channel is not
        % reciprocal
        reset(chan);
    
        % Generate HE Ranging NDP transmission
        txWaveform = ranging.heRangingWaveformGenerator(cfg);
    
        % Introduce time delay (fractional and integer) in the transmit waveform
        txDelay = ranging.heDelaySignal(txWaveform, sampleDelay);
    
        % Pad signal and pass through multipath channel (that's the raytraced channel!)
        [txMultipath, CIR] = chan(txDelay); % <-- This is the key change to the 802.11az example!
    
        % Pass waveform through AWGN channel
        rxWaveform = awgn(txMultipath,snrVal);
    
        % Perform synchronization and channel estimation
        [chanEstActiveSC,integerOffset] = ranging.heRangingSynchronize(rxWaveform,cfg); % << chanEstActiveSC looks like it could be CSI!
    
        % Output Per-Snapshot Channel State Information [AT AR S K]
        if (size(chanEstActiveSC, 1) > 0) % Sometimes, we can't solve for it. This frame is dropped.
            Hest_Multi(:, :, :, k) = permute(chanEstActiveSC, [2 3 1]); % [AT AR S K]
        end
                
        % Estimate the transmission time between UL and DL
        if ~isempty(chanEstActiveSC) % If packet detection is successful
            % Estimate fractional delay with MUSIC super-resolution
            fracDelay = ranging.heRangingTOAEstimate(chanEstActiveSC,ofdmInfo.ActiveFFTIndices,...
                                            ofdmInfo.FFTLength, sampleRate, numPaths);
            integerOffset = integerOffset - chDelay;    % Account for channel filter delay
            intDelay = integerOffset/sampleRate;        % Estimate integer time delay
            txTime(l) = intDelay + fracDelay;           % Transmission time
        else % Packet detection failed
            txTime(l) = NaN;
        end
    end
    
    if ~any(isnan(txTime)) % If packet detection succeeds
        % TOA of UL waveform (t2)
        toaUL = todUL + txTime(1);
    
        % Time of departure of DL waveform (t3)
        todDL = toaUL + delayULDL;
    
        % TOA DL waveform (t4)
        toaDL = todDL + txTime(2);
    
        % Compute the RTT
        rtt = (toaDL-todUL) - (todDL-toaUL);
    
        % Estimate distance between STA and AP
        distEst = (rtt/2) * c;
        % Accumulate error
        rangingError = rangingError + abs(distance(tx, rx) - distEst);
    else % If packet detection fails
        distEst = NaN;
        failedPackets = failedPackets + 1;
    end
end

%% Determine DOA via Naive (Phased Array) Method
doa = doa_lib.naive_doa(chanEstActiveSC, spacing);

%% Determine DOA via MUSIC 'Plus' Method
rxElemPos = helper.getElementPosition(rxArray).'; % Extract Element Positions
Hest = Hest_Multi;
Hest(Hest(1, 1, 1, :) == 0) = []; % Remove dropped frames (if any were found)
[~, doa_plus] = doa_lib.naive_doa_plus(Hest, fc, bw, rxElemPos);

%% Display results
disp(['At SNR = ', num2str(SNR), ' dB, estimated distance ', ...
      num2str(distEst), 'm for true distance ', num2str(distance(tx, rx))]);
disp(['Naive DoA estimated at [' num2str(mean(doa(1:3))) '] deg for true DoA ' num2str(beta_a) ' deg']);

% Set up plots
figure; rows = 2; cols = 2; sgtitle("CSI Estimation from Ranging Process & Perfect Channel Estimator. DOA="+num2str(beta_a)+"deg");
%% Plot CSI from generated by Ranging Process
%e.g.: traceLegend = ["Elem 1", "Elem 2", "Elem 3", "Elem 4"];
traceLegend = arrayfun(@(x) ['Elem ' num2str(x)], 1:numAPant, 'UniformOutput', false);

ranging_chanEst = chanEstActiveSC; % Generated by heRangingSynchronize(...)
Hest = ranging_chanEst; Hest_flat = reshape(Hest, [size(Hest,1), size(Hest, 2)*size(Hest,3)]);
x = (-size(Hest_flat, 1)/2:1:(size(Hest_flat,1)/2 - 1))';
subplot(rows, cols, cols*0 + 1); plot(x, mag2db(abs(Hest_flat))); title("Ranging: CSI Magnitude"); xlabel("Subcarrier Index"); ylabel("Magnitude (dB)"); grid on; legend(traceLegend);
subplot(rows, cols, cols*1 + 1); plot(x, rad2deg(angle(Hest_flat))); title("Ranging: CSI Phase"); xlabel("Subcarrier Index"); ylabel("Phase (deg)"); grid on; yticks(-180:30:180); legend(traceLegend);

%% Plot CSI (?) via Perfect Channel Estimation
% From `helperIndoorRayTracingRxProcessing`, modified to fit the output
%  from ofdmInfo ~ wlanHEOFDMInfo (instead of direction OFDM mod/demodulator)
% Retrieve OFDM Parameters
fftLen = ofdmInfo.FFTLength;
cpLen = ofdmInfo.CPLength;
pilotCarrierIdx = ofdmInfo.PilotIndices;
dataCarrierIdx = ofdmInfo.DataIndices; % Use it directly for data subcarriers
% Data carriers excluding pilots and guard bands, so no need for setdiff
% However, if DC carrier needs to be excluded, keep the following line:
dataCarrierIdx = setdiff(dataCarrierIdx, fftLen/2 + 1);

% Perfect Channel Estimation
chanDelay = channelDelay(CIR, chBaseInfo.ChannelFilterCoefficients);
chanEst = ofdmChannelResponse(CIR, chBaseInfo.ChannelFilterCoefficients, ...
                                fftLen, cpLen, dataCarrierIdx, chanDelay);
% Plot.
% Case when exposing chanEst, which has a bunch of symbols. We pick the first symbol, then graph the CSI for it
dims = size(chanEst(:,1,:,:)); Hest = reshape(chanEst(:,1,:,:), [dims(1),dims(3:end)]);
Hest_flat = reshape(Hest, [size(Hest,1), size(Hest, 2)*size(Hest,3)]);
x = (-size(Hest_flat, 1)/2:1:(size(Hest_flat,1)/2 - 1))';
subplot(rows, cols, cols*0 + 2); plot(x, mag2db(abs(Hest_flat))); title("Perfect: CSI Magnitude"); xlabel("Subcarrier Index"); ylabel("Magnitude (dB)"); grid on; legend(traceLegend);
subplot(rows, cols, cols*1 + 2); plot(x, rad2deg(angle(Hest_flat))); title("Perfect: CSI Phase"); xlabel("Subcarrier Index"); ylabel("Phase (deg)"); grid on; yticks(-180:30:180); legend(traceLegend);
%% MIMO-OFDM Raytracing Comm + 802.11az Super-Resolution Time of Arrival Estimator
% Combination of MIMO-OFDM example: https://www.mathworks.com/help/comm/ug/indoor-mimo-ofdm-communication-link-using-ray-tracing.html
% and 802.11az Positioning example: https://www.mathworks.com/help/wlan/ug/802-11az-indoor-positioning-using-super-resolution-time-of-arrival-estimation.html

% VARIABLES OF INTEREST
% numSTAant = # of Transmit Antennas on User Terminal
% numAPant = # of Receive Antennas on Base Station
% R_a = Linear Distance from TX to RX
% beta_a = Angular Position of RX relative to TX (angle off array parallel)
% tx.AntennaPosition = TX antenna position
% rx.AntennaPosition = RX antenna position
% pm.MaxNumReflections = 
% EbNo = approximate EbNo for system. To remove noise, set EbNo = inf
% 

clear all;
close all;
%clc;

%% 3D Indoor Scenario
mapFileName = "conferenceroom.stl";

c = physconst('lightspeed');
fc = 5.8e9; % Carrier frequency
lambda = c/fc;
spacing = 3/4; % 3/4 Lambda Spacing

numSTAant = 1;  % # of Transmit Antennas (on User Terminal)
numAPant = 4;   % # of Receive Antennas (on Base Station)
txArray = arrayConfig("Size",[1 numSTAant],"ElementSpacing",spacing*lambda);
rxArray = arrayConfig("Size",[1 numAPant],"ElementSpacing",spacing*lambda);

R_a = 20; % Linear Distance between TX and RX
beta_a = 90-37; % Direction of TX, with respect to RX (in degrees)
            % 0 degrees is parallel to the array, on the right-hand side
            %   relative to the X-Z plane visualized by `helperViewArray`
            % 10 degrees moves clockwise about the Z axis 

%helperViewArray(txArray); % To visualize the TX APA
helperViewArray(rxArray); % For RX URA APA

% Specify a transmitter site close to the upper corner of the room, which
% can be a WiFi accesss point
tx = txsite("cartesian", ...
    "Antenna",txArray, ...
    'TransmitterFrequency',fc);

rx = rxsite("cartesian", ...
    "Antenna",rxArray, ...
    "AntennaAngle",[0; 0]); % Rotate RX array by the angle we're trying to simulate

%tx.AntennaPosition = [R_a*cos(deg2rad(beta_a - 90)); R_a*sin(deg2rad(beta_a - 90)); 0]; % Place TX Antenna some distance away
%rx.AntennaPosition = [0; 0; 0];       % Place RX Antenna at the origin (for free space modeling)
tx.AntennaPosition = [-1.46; -1.42; 2.1];   % Position from Example
rx.AntennaPosition = [.3; .3; .85];         % Position from Example

% Use the siteviewer function with the map file specified to view the scene
% in 3D. Use show function to visualize the transmitters and receivers
siteviewer("SceneModel",mapFileName);
%siteviewer("Terrain", 'none', "Hidden",true); % To have 'nothing' / empty space - for free space modeling
show(tx,"ShowAntennaHeight",false)
show(rx,"ShowAntennaHeight",false)
pattern(rx, fc); % For a ULA, the array is facing the direction of the main lobe, flaring out at the sides

%% Ray Tracing Model
% Perform raytracing analysis between the transmitter and receiver sites
% and return the comm.Ray objects, using the Shooting and Bouncing rays
% (SBR) method. Specify the surface material of the scene as wood and
% search for rays with up to 2 reflections. SBR method supports up to 10
% orders of reflections
pm = propagationModel("raytracing", ...
    "CoordinateSystem","cartesian", ...
    "Method","sbr", ...
    "AngularSeparation","low", ...
    "SurfaceMaterial","plasterboard");
pm.MaxNumReflections = 2; % If 0: No reflections, LOS only

rays = raytrace(tx,rx,pm);

% Extract computed rays from the cell array return
rays = rays{1,1};
% Examine the ray tracing results by looking at the number of reflections:
[rays.NumInteractions]
% ...propagation distance...
[rays.PropagationDistance]
% ...and path loss value of each ray
[rays.PathLoss]
% Use the plot function to plot the rays in the 3D scene in Siteviewer,
% with each ray colored based on path loss value
plot(rays,"Colormap",jet,"ColorLimits",[50, 95]);

%% Deterministic Channel Model from Ray Tracing
% Create a deterministic multipath channel model using the above ray
% tracing results. Specify the instananeous velocity of the receiver to
% reflect typical low mobility of a device in the indoor environment
rtChan = comm.RayTracingChannel(rays,tx,rx);
rtChan.SampleRate = 300e6;
rtChan.ReceiverVirtualVelocity = [0.1;0.1;0];

% Assign Eb/No value and derive SNR value from it for AWGN
bitsPerCarrier = 6; % Suppose we're using 64-QAM, which exists for 802.11ac & az
codeRate = 2/3;     % worst case 1/2, best case 5/6
EbNo = 16; % In dB
SNR = convertSNR(EbNo,"ebno", ...
  "BitsPerSymbol",bitsPerCarrier, ... % worst case 1, best case 10
  "CodingRate",codeRate);             % worst case 1/2, best case 5/6  
SNRLin = 10^(SNR/10);      % Linear

%% 802.11az Waveform Configuration
bw = 20;
chanBW = "CBW"+num2str(bw); % 20MHz Channel
numSTS = min([numSTAant numAPant]);%numSTAant * numAPant; % # of Space-Time Streams
numLTFRepetitions = 8;  % # of HE-LTF repetitions

% Configure the HE ranging NDP parameters of the STA (User Terminal)
cfgSTABase = heRangingConfig;
cfgSTABase.ChannelBandwidth = chanBW;
cfgSTABase.NumTransmitAntennas = numSTAant;
cfgSTABase.SecureHELTF = true;
cfgSTABase.User{1}.NumSpaceTimeStreams = numSTS;
cfgSTABase.User{1}.NumHELTFRepetition = numLTFRepetitions;
cfgSTABase.GuardInterval = 1.6;

% Configure HE ranging NDP parameters of the AP (Base Station)
cfgAPBase = heRangingConfig;
cfgAPBase.ChannelBandwidth = chanBW;
cfgAPBase.NumTransmitAntennas = min([numSTAant numAPant]);
cfgAPBase.SecureHELTF = true;
cfgAPBase.User{1}.NumSpaceTimeStreams = numSTS;
cfgAPBase.User{1}.NumHELTFRepetition = numLTFRepetitions;
cfgAPBase.GuardInterval = 1.6;

ofdmInfo = wlanHEOFDMInfo('HE-LTF',chanBW,cfgSTABase.GuardInterval);
sampleRate = wlanSampleRate(chanBW);

% Miscellaneous channel config variables
chBaseInfo = info(rtChan);
chDelay = chBaseInfo.ChannelFilterDelay;
numPaths = size(rays, 2); % Number of paths simulated

%% Ranging Measurement
delayULDL = 16e-6; % Time Delay between UL NDP ToA and DL NDP ToD, in seconds

% Use a separate channel and waveform config object for each (potential)
% parfor stream, which would start here. -- Iterates over the SNR values
chan = rtChan; % Set it to the Raytracing Channel we generated earlier
cfgAP = cfgAPBase;
cfgSTA = cfgSTABase;

% Initialize ranging error and total failed packet count variables
rangingError = 0;
failedPackets = 0;

% Set random substream index per (potential) iteration to ensure each
% iteration uses a repeatable set of random numbers
stream = RandStream('combRecursive','Seed',654321);
stream.Substream = 1; % Would be equal to index in parfor loop
RandStream.setGlobalStream(stream);

% Define SNR per active subcarrier to account for noise energy in nulls
snrVal = SNR - 10*log10(ofdmInfo.FFTLength/ofdmInfo.NumTones);

% 802.11az Pos Example starts Monte Carlo here
% Range-based delay
delay = distance(tx, rx)/c; % Divide out the speed of light
sampleDelay = delay*sampleRate;

% Loop over different APs starts here
linkType = ["Uplink","Downlink"];
% ToD of UL NDP (t1)
todUL = randsrc(1,1,0:1e-9:1e-6);
% Loop for both UL and DL transmission
numLinks = numel(linkType);
txTime = zeros(1,numLinks);

for l = 1:numLinks
    if linkType(l) == "Uplink" % STA to AP
        cfgSTA.UplinkIndication = 1; % For UL
        % Generate a random secure HE-LTF sequence for the exchange
        cfgSTA.User{1}.SecureHELTFSequence = dec2hex(randsrc(1,10,(0:15)))';
        cfg = cfgSTA;
    else                        % AP to STA
        % Generate a random secure HE-LTF sequence for the exchange
        cfgAP.User{1}.SecureHELTFSequence = dec2hex(randsrc(1,10,(0:15)))';
        cfg = cfgAP;    % For DL
    end

    % Set different channel for UL and DL, assuming that the channel is not
    % reciprocal
    reset(chan);

    % Generate HE Ranging NDP transmission
    txWaveform = heRangingWaveformGenerator(cfg);

    % Introduce time delay (fractional and integer) in the transmit waveform
    txDelay = heDelaySignal(txWaveform, sampleDelay);

    % Pad signal and pass through multipath channel (that's the raytraced channel!)
    [txMultipath, CIR] = chan(txDelay); % <-- This is the key change to the 802.11az example!

    % Pass waveform through AWGN channel
    rxWaveform = awgn(txMultipath,snrVal);

    % Perform synchronization and channel estimation
    [chanEstActiveSC,integerOffset] = heRangingSynchronize(rxWaveform,cfg); % << chanEstActiveSC looks like it could be CSI!

    % Estimate the transmission time between UL and DL
    if ~isempty(chanEstActiveSC) % If packet detection is successful
        % Estimate fractional delay with MUSIC super-resolution
        fracDelay = heRangingTOAEstimate(chanEstActiveSC,ofdmInfo.ActiveFFTIndices,...
                                        ofdmInfo.FFTLength, sampleRate, numPaths);
        integerOffset = integerOffset - chDelay;    % Account for channel filter delay
        intDelay = integerOffset/sampleRate;        % Estimate integer time delay
        txTime(l) = intDelay + fracDelay;           % Transmission time
    else % Packet detection failed
        txTime(l) = NaN;
    end
end

if ~any(isnan(txTime)) % If packet detection succeeds
    % TOA of UL waveform (t2)
    toaUL = todUL + txTime(1);

    % Time of departure of DL waveform (t3)
    todDL = toaUL + delayULDL;

    % TOA DL waveform (t4)
    toaDL = todDL + txTime(2);

    % Compute the RTT
    rtt = (toaDL-todUL) - (todDL-toaUL);

    % Estimate distance between STA and AP
    distEst = (rtt/2) * c;
    % Accumulate error
    rangingError = rangingError + abs(distance(tx, rx) - distEst);
else % If packet detection fails
    distEst = NaN;
    failedPackets = failedPackets + 1;
end

% Separately, determine distance via Naive ToF:
%naive_csi = reshape(chanEstActiveSC, [size(chanEstActiveSC, 1), size(chanEstActiveSC, 2)*size(chanEstActiveSC, 3)]);
%naive_csi = permute(naive_csi, [4 1 2 3]); % Add a singleton dimension to front and back
%tof_mat = naive_tof(naive_csi, bw);
%naive_dist = mean(tof_mat * c, 'all');

%% Display results
disp(['At SNR = ', num2str(SNR), ' dB, estimated distance ', ...
      num2str(distEst), 'm for true distance ', num2str(distance(tx, rx))]);
%disp(['Distance via Naive ToF: ' num2str(naive_dist) 'm']);

% Set up plots
figure; rows = 2; cols = 2; sgtitle("CSI Estimation from Ranging Process & Perfect Channel Estimator. DOA="+num2str(beta_a)+"deg");
%% Plot CSI from generated by Ranging Process
traceLegend = ["Elem 1", "Elem 2", "Elem 3", "Elem 4"];

ranging_chanEst = chanEstActiveSC; % Generated by heRangingSynchronize(...)
Hest = ranging_chanEst; Hest_flat = reshape(Hest, [size(Hest,1), size(Hest, 2)*size(Hest,3)]);
x = (-size(Hest_flat, 1)/2:1:(size(Hest_flat,1)/2 - 1))';
subplot(rows, cols, cols*0 + 1); plot(x, abs(Hest_flat)); title("Ranging: CSI Magnitude"); xlabel("Subcarrier Index?"); ylabel("Magnitude (dB?)"); grid on; legend(traceLegend);
subplot(rows, cols, cols*1 + 1); plot(x, rad2deg(angle(Hest_flat))); title("Ranging: CSI Phase"); xlabel("Subcarrier Index?"); ylabel("Phase (deg)"); grid on; yticks(-180:30:180); legend(traceLegend);

%% Plot CSI (?) via Perfect Channel Estimation
% From `helperIndoorRayTracingRxProcessing`, modified to fit the output
%  from ofdmInfo ~ wlanHEOFDMInfo (instead of direction OFDM mod/demodulator)
% Retrieve OFDM Parameters
fftLen = ofdmInfo.FFTLength;
cpLen = ofdmInfo.CPLength;
pilotCarrierIdx = ofdmInfo.PilotIndices;
%dataCarrierIdx = setdiff( ... %<<<--- Original
%    numGuardBandCarriers(1)+1:fftLen-numGuardBandCarriers(2), ...
%    [pilotCarrierIdx; fftLen/2+1]);
dataCarrierIdx = ofdmInfo.DataIndices; % Use it directly for data subcarriers
% Data carriers excluding pilots and guard bands, so no need for setdiff
% However, if DC carrier needs to be excluded, keep the following line:
dataCarrierIdx = setdiff(dataCarrierIdx, fftLen/2 + 1);

% Perfect Channel Estimation
chanDelay = channelDelay(CIR, chBaseInfo.ChannelFilterCoefficients);
chanEst = ofdmChannelResponse(CIR, chBaseInfo.ChannelFilterCoefficients, ...
                                fftLen, cpLen, dataCarrierIdx, chanDelay);
% Plot.
% Case when exposing chanEst, which has a bunch of symbols. We pick the first symbol, then graph the CSI for it
dims = size(chanEst(:,1,:,:)); Hest = reshape(chanEst(:,1,:,:), [dims(1),dims(3:end)]);
Hest_flat = reshape(Hest, [size(Hest,1), size(Hest, 2)*size(Hest,3)]);
x = (-size(Hest_flat, 1)/2:1:(size(Hest_flat,1)/2 - 1))';
subplot(rows, cols, cols*0 + 2); plot(x, abs(Hest_flat)); title("Perfect: CSI Magnitude"); xlabel("Subcarrier Index?"); ylabel("Magnitude (dB?)"); grid on; legend(traceLegend);
subplot(rows, cols, cols*1 + 2); plot(x, rad2deg(angle(Hest_flat))); title("Perfect: CSI Phase"); xlabel("Subcarrier Index?"); ylabel("Phase (deg)"); grid on; yticks(-180:30:180); legend(traceLegend);